
prompts:
  - $cndi.get_block(https://raw.githubusercontent.com/polyseam/common-blocks/main/common/core-prompts.yaml):
      {}
  - $cndi.get_block(https://raw.githubusercontent.com/polyseam/common-blocks/main/{{ $cndi.get_prompt_response(deployment_target_provider) }}/setup-prompts.yaml):
      {} 

  - name: kafka_cluster_name
    default: kafka-cluster
    message: >-
      What will be the name for your Kafka cluster?
    type: Input

  - name: aws_hosted_zone_id
    default: "ABC123XYZ987DEF456"
    message: >-
      What is the aws hosted zone id?
    type: Input

  - name: aws_dns_zone
    default: "example.com"
    message: >-
      What is the aws dns zone you would like to target?
    type: Input

  - name: deploy_argocd_ingress
    default: true
    message: >-
      Do you want to expose ArgoCD with an Ingress?
    type: Confirm

  - name: argocd_hostname
    default: argocd.example.com
    message: >-
      What hostname should ArgoCD be accessible at?
    type: Input
    validators:
      - hostname # FQDN
    condition:
      - "{{ $cndi.get_prompt_response(deploy_argocd_ingress) }}"
      - ==
      - true

outputs:
  cndi_config:
    cndi_version: v2
    project_name: "{{ $cndi.get_prompt_response(project_name) }}"
    provider: "{{ $cndi.get_prompt_response(deployment_target_provider) }}"
    distribution: "{{ $cndi.get_prompt_response(deployment_target_distribution) }}"
    infrastructure:
      cndi:
        external_dns: 
          $cndi.get_block(https://raw.githubusercontent.com/polyseam/common-blocks/main/external-dns/config.yaml):
            condition:
              - "{{ $cndi.get_prompt_response(enable_external_dns) }}"
              - ==
              - true
            args:
              dns_provider: "{{ $cndi.get_prompt_response(dns_provider) }}"

        cert_manager:
          email: "{{ $cndi.get_prompt_response(cert_manager_email) }}"

        nodes:
          $cndi.get_block(https://raw.githubusercontent.com/polyseam/common-blocks/main/{{ $cndi.get_prompt_response(deployment_target_provider) }}/{{ $cndi.get_prompt_response(deployment_target_distribution) }}/standard-nodes.yaml):
            {}

    cluster_manifests:
      external-dns-secret: 
        $cndi.get_block(https://raw.githubusercontent.com/polyseam/common-blocks/main/external-dns/secret/{{ $cndi.get_prompt_response(dns_provider) }}.yaml):
          condition:
            - "{{ $cndi.get_prompt_response(enable_external_dns) }}"
            - ==
            - true      
      cluster-issuer-dns01:
        apiVersion: cert-manager.io/v1
        kind: ClusterIssuer
        metadata:
          name: cluster-issuer-dns01
        spec:
          acme:
            email: "{{ $cndi.get_prompt_response(cert_manager_email) }}"
            preferredChain: ""
            server: https://acme-v02.api.letsencrypt.org/directory
            privateKeySecretRef:
              name: cluster-issuer-private-key
            solvers:
            - dns01:
                route53:
                  hostedZoneID: "{{ $cndi.get_prompt_response(aws_hosted_zone_id) }}"
                  region: "{{ $cndi.get_prompt_response(aws_region) }}"
                  accessKeyIDSecretRef:
                    name: cluster-issuer-dns01-secret
                    key: access-key-id             
                  secretAccessKeySecretRef:
                    key: secret-access-key
                    name: cluster-issuer-dns01-secret
              selector:
                dnsZones:
                - "{{ $cndi.get_prompt_response(aws_dns_zone) }}"
      cluster-issuer-dns01-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: cluster-issuer-dns01-certificate
        spec:
          secretName: cluster-issuer-private-key
          issuerRef:
            name: cluster-issuer-dns01
            kind: ClusterIssuer
            group: cert-manager.io
          subject:
            organizations:
              - my-org
          dnsNames:
            - "{{ $cndi.get_prompt_response(aws_dns_zone) }}"
      cluster-issuer-dns01-secret:
        apiVersion: v1
        kind: Secret
        metadata:
          name: cluster-issuer-dns01-secret
          namespace: cert-manager
        type: Opaque
        stringData:
          access-key-id : $cndi_on_ow.seal_secret_from_env_var(AWS_ACCESS_KEY_ID)
          secret-access-key: $cndi_on_ow.seal_secret_from_env_var(AWS_SECRET_ACCESS_KEY)            
      kafka-cluster:
        apiVersion: kafka.strimzi.io/v1beta2
        kind: Kafka
        metadata:
          annotations:
            argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
          name: "{{ $cndi.get_prompt_response(kafka_cluster_name) }}"
          namespace: kafka
          labels:
            app: "{{ $cndi.get_prompt_response(kafka_cluster_name) }}"
        spec:
          kafka:
            replicas: 3
            listeners:
              - name: plain
                port: 9092
                type: internal
                tls: false
              - name: tls
                port: 9093
                type: internal
                tls: true
              - name: external
                port: 9094
                type: ingress
                tls: true
                authentication:
                  type: tls
                configuration:
                  class: public
                  bootstrap:
                    host: "bootstrap.{{ $cndi.get_prompt_response(aws_dns_zone) }}"
                    annotations:
                      external-dns.alpha.kubernetes.io/hostname: "bootstrap.{{ $cndi.get_prompt_response(aws_dns_zone) }}."
                      external-dns.alpha.kubernetes.io/ttl: "60"
                      cert-manager.io/cluster-issuer: cluster-issuer-dns01
                  brokers:
                    - broker: 0
                      annotations:
                        external-dns.alpha.kubernetes.io/hostname: "broker-0.{{ $cndi.get_prompt_response(aws_dns_zone) }}."
                        external-dns.alpha.kubernetes.io/ttl: "60"
                        cert-manager.io/cluster-issuer: cluster-issuer-dns01
                      host: "broker-0.{{ $cndi.get_prompt_response(aws_dns_zone) }}"
                    - broker: 1
                      annotations:
                        external-dns.alpha.kubernetes.io/hostname: "broker-1.{{ $cndi.get_prompt_response(aws_dns_zone) }}."
                        external-dns.alpha.kubernetes.io/ttl: "60"
                        cert-manager.io/cluster-issuer: cluster-issuer-dns01
                      host: "broker-1.{{ $cndi.get_prompt_response(aws_dns_zone) }}"
                    - broker: 2
                      annotations:
                        external-dns.alpha.kubernetes.io/hostname: "broker-2.{{ $cndi.get_prompt_response(aws_dns_zone) }}."
                        external-dns.alpha.kubernetes.io/ttl: "60"
                        cert-manager.io/cluster-issuer: cluster-issuer-dns01
                      host: "broker-2.{{ $cndi.get_prompt_response(aws_dns_zone) }}"
                  brokerCertChainAndKey:
                    secretName: cluster-issuer-private-key
                    certificate: tls.crt
                    key: tls.key
            config:
              auto.create.topics.enable: "false"
              offsets.topic.replication.factor: 3
              transaction.state.log.replication.factor: 3
              transaction.state.log.min.isr: 2
            storage:
              type: jbod
              volumes:
                - id: 0
                  type: persistent-claim
                  size: 10Gi
                  deleteClaim: true
          zookeeper:
            replicas: 3
            storage:
              type: persistent-claim
              size: 10Gi
              deleteClaim: true
          entityOperator:
            topicOperator: {}
            userOperator: {} 
       
      argo-ingress:
        $cndi.get_block(https://raw.githubusercontent.com/polyseam/common-blocks/main/common/default-ingress.yaml):
          args:
            ingress_name: argocd-ingress
            ingress_class_name: public
            hostname: "{{ $cndi.get_prompt_response(argocd_hostname) }}"
            service_name: argocd-server
            service_port: 443
            namespace: argocd
          condition:
            - "{{ $cndi.get_prompt_response(deploy_argocd_ingress) }}"
            - ==
            - true

    applications:
      kafka:
        targetRevision: 0.40.0
        destinationNamespace: kafka
        repoURL: 'https://strimzi.io/charts/'
        chart: strimzi-kafka-operator

  env:
    $cndi.get_block(https://raw.githubusercontent.com/polyseam/common-blocks/main/{{ $cndi.get_prompt_response(deployment_target_provider) }}/env.yaml):
      {}

  readme:
    project_name: "# {{ $cndi.get_prompt_response(project_name) }}"
    $cndi.get_string(https://raw.githubusercontent.com/polyseam/common-blocks/main/common/core-readme.md):
      {}
    $cndi.get_string(https://raw.githubusercontent.com/polyseam/common-blocks/main/{{ $cndi.get_prompt_response(deployment_target_provider) }}/{{ $cndi.get_prompt_response(deployment_target_distribution) }}/readme-section.md):
      {}
    airflow-section: |
      # Strimzi Kafka Deployment Guide

      This Template deploys a production-ready [Strimzi Kafka](https://strimzi.io/) cluster on a Kubernetes environment. Strimzi provides a way to run an Apache Kafka cluster on Kubernetes in various deployment configurations. It simplifies the process of running Kafka on Kubernetes, ensuring scalability and security for Kafka clusters.

      ## Configuration

      Configuring your Kafka deployment is straightforward with Strimzi's extensive options, adjustable in the `strimzi_config.yaml` file under `kafka`. Key configuration areas include:

      - **Cluster Size:** Define the number of brokers in your Kafka cluster for scalability.
      - **Storage:** Configure persistent storage for brokers to ensure data durability.
      - **Topic Management:** Automate topic creation, deletion, and configuration changes.
      - **Security:** Implement encryption, authentication, and authorization for secure communication.

      For comprehensive details on all configurable values, please refer to the [Strimzi documentation](https://strimzi.io/docs/operators/latest/using.html) and the specific configuration files within the Strimzi GitHub repository.

      ## Verifying Kafka Cluster Functionality

      ### Steps for Verification

      **Access the Kafka Cluster**:
      - Utilize the `kubectl` command to interact with your Kafka cluster within Kubernetes. For example, to list all Kafka topics:
        ```shell
        kubectl get kafkatopics```
